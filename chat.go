package slack

// Auto-generated by internal/cmd/genmethods/genmethods.go. DO NOT EDIT!

import (
	"context"
	"net/url"
	"strconv"

	"github.com/lestrrat/go-slack/objects"
	"github.com/pkg/errors"
)

var _ = strconv.Itoa
var _ = objects.EpochTime(0)

// ChatDeleteCall is created by ChatService.Delete method call
type ChatDeleteCall struct {
	service   *ChatService
	asUser    bool
	channel   string
	timestamp string
}

// ChatMeMessageCall is created by ChatService.MeMessage method call
type ChatMeMessageCall struct {
	service *ChatService
	channel string
	text    string
}

// ChatPostMessageCall is created by ChatService.PostMessage method call
type ChatPostMessageCall struct {
	service     *ChatService
	asUser      bool
	attachments objects.AttachmentList
	channel     string
	escapeText  bool
	iconEmoji   string
	iconURL     string
	linkNames   bool
	markdown    bool
	parse       string
	text        string
	unfurlLinks bool
	unfurlMedia bool
	username    string
}

// ChatUpdateCall is created by ChatService.Update method call
type ChatUpdateCall struct {
	service     *ChatService
	asUser      bool
	attachments objects.AttachmentList
	channel     string
	linkNames   bool
	parse       string
	text        string
	timestamp   string
}

// Delete creates a ChatDeleteCall object in preparation for accessing the chat.delete endpoint
func (s *ChatService) Delete(channel string) *ChatDeleteCall {
	var call ChatDeleteCall
	call.service = s
	call.channel = channel
	return &call
}

func (c *ChatDeleteCall) AsUser(asUser bool) *ChatDeleteCall {
	c.asUser = asUser
	return c
}

func (c *ChatDeleteCall) Timestamp(timestamp string) *ChatDeleteCall {
	c.timestamp = timestamp
	return c
}

// Values() returns the ChatDeleteCall object as url.Values
func (c *ChatDeleteCall) Values() (url.Values, error) {
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.asUser {
		v.Set("asUser", "true")
	}

	if len(c.channel) <= 0 {
		return nil, errors.New(`missing required parameter channel`)
	}
	v.Set("channel", c.channel)

	if len(c.timestamp) > 0 {
		v.Set("ts", c.timestamp)
	}
	return v, nil
}

// Do executes the call to access chat.delete endpoint
func (c *ChatDeleteCall) Do(ctx context.Context) (*ChatResponse, error) {
	const endpoint = "chat.delete"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res struct {
		SlackResponse
		*ChatResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to chat.delete`)
	}
	if !res.OK {
		return nil, errors.New(res.Error.String())
	}

	return res.ChatResponse, nil
}

// MeMessage creates a ChatMeMessageCall object in preparation for accessing the chat.meMessage endpoint
func (s *ChatService) MeMessage(channel string) *ChatMeMessageCall {
	var call ChatMeMessageCall
	call.service = s
	call.channel = channel
	return &call
}

func (c *ChatMeMessageCall) Text(text string) *ChatMeMessageCall {
	c.text = text
	return c
}

// Values() returns the ChatMeMessageCall object as url.Values
func (c *ChatMeMessageCall) Values() (url.Values, error) {
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if len(c.channel) <= 0 {
		return nil, errors.New(`missing required parameter channel`)
	}
	v.Set("channel", c.channel)

	if len(c.text) > 0 {
		v.Set("text", c.text)
	}
	return v, nil
}

// Do executes the call to access chat.meMessage endpoint
func (c *ChatMeMessageCall) Do(ctx context.Context) (*ChatResponse, error) {
	const endpoint = "chat.meMessage"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res struct {
		SlackResponse
		*ChatResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to chat.meMessage`)
	}
	if !res.OK {
		return nil, errors.New(res.Error.String())
	}

	return res.ChatResponse, nil
}

// PostMessage creates a ChatPostMessageCall object in preparation for accessing the chat.postMessage endpoint
func (s *ChatService) PostMessage(channel string) *ChatPostMessageCall {
	var call ChatPostMessageCall
	call.service = s
	call.channel = channel
	return &call
}

func (c *ChatPostMessageCall) AsUser(asUser bool) *ChatPostMessageCall {
	c.asUser = asUser
	return c
}

func (c *ChatPostMessageCall) SetAttachments(attachments objects.AttachmentList) *ChatPostMessageCall {
	c.attachments = attachments
	return c
}

func (c *ChatPostMessageCall) Attachment(attachment *objects.Attachment) *ChatPostMessageCall {
	c.attachments.Append(attachment)
	return c
}

func (c *ChatPostMessageCall) EscapeText(escapeText bool) *ChatPostMessageCall {
	c.escapeText = escapeText
	return c
}

func (c *ChatPostMessageCall) IconEmoji(iconEmoji string) *ChatPostMessageCall {
	c.iconEmoji = iconEmoji
	return c
}

func (c *ChatPostMessageCall) IconURL(iconURL string) *ChatPostMessageCall {
	c.iconURL = iconURL
	return c
}

func (c *ChatPostMessageCall) LinkNames(linkNames bool) *ChatPostMessageCall {
	c.linkNames = linkNames
	return c
}

func (c *ChatPostMessageCall) Markdown(markdown bool) *ChatPostMessageCall {
	c.markdown = markdown
	return c
}

func (c *ChatPostMessageCall) Parse(parse string) *ChatPostMessageCall {
	c.parse = parse
	return c
}

func (c *ChatPostMessageCall) Text(text string) *ChatPostMessageCall {
	c.text = text
	return c
}

func (c *ChatPostMessageCall) UnfurlLinks(unfurlLinks bool) *ChatPostMessageCall {
	c.unfurlLinks = unfurlLinks
	return c
}

func (c *ChatPostMessageCall) UnfurlMedia(unfurlMedia bool) *ChatPostMessageCall {
	c.unfurlMedia = unfurlMedia
	return c
}

func (c *ChatPostMessageCall) Username(username string) *ChatPostMessageCall {
	c.username = username
	return c
}

// Values() returns the ChatPostMessageCall object as url.Values
func (c *ChatPostMessageCall) Values() (url.Values, error) {
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.asUser {
		v.Set("asUser", "true")
	}

	if len(c.attachments) > 0 {
		attachmentsEncoded, err := c.attachments.Encode()
		if err != nil {
			return nil, errors.Wrap(err, `failed to encode field`)
		}
		v.Set("attachments", attachmentsEncoded)
	}

	if len(c.channel) <= 0 {
		return nil, errors.New(`missing required parameter channel`)
	}
	v.Set("channel", c.channel)

	if c.escapeText {
		v.Set("escapeText", "true")
	}

	if len(c.iconEmoji) > 0 {
		v.Set("iconEmoji", c.iconEmoji)
	}

	if len(c.iconURL) > 0 {
		v.Set("iconURL", c.iconURL)
	}

	if c.linkNames {
		v.Set("linkNames", "true")
	}

	if c.markdown {
		v.Set("markdown", "true")
	}

	if len(c.parse) > 0 {
		v.Set("parse", c.parse)
	}

	if len(c.text) > 0 {
		v.Set("text", c.text)
	}

	if c.unfurlLinks {
		v.Set("unfurlLinks", "true")
	}

	if c.unfurlMedia {
		v.Set("unfurlMedia", "true")
	}

	if len(c.username) > 0 {
		v.Set("username", c.username)
	}
	return v, nil
}

// Do executes the call to access chat.postMessage endpoint
func (c *ChatPostMessageCall) Do(ctx context.Context) (*ChatResponse, error) {
	const endpoint = "chat.postMessage"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res struct {
		SlackResponse
		*ChatResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to chat.postMessage`)
	}
	if !res.OK {
		return nil, errors.New(res.Error.String())
	}

	return res.ChatResponse, nil
}

// Update creates a ChatUpdateCall object in preparation for accessing the chat.update endpoint
func (s *ChatService) Update(channel string) *ChatUpdateCall {
	var call ChatUpdateCall
	call.service = s
	call.channel = channel
	return &call
}

func (c *ChatUpdateCall) AsUser(asUser bool) *ChatUpdateCall {
	c.asUser = asUser
	return c
}

func (c *ChatUpdateCall) SetAttachments(attachments objects.AttachmentList) *ChatUpdateCall {
	c.attachments = attachments
	return c
}

func (c *ChatUpdateCall) Attachment(attachment *objects.Attachment) *ChatUpdateCall {
	c.attachments.Append(attachment)
	return c
}

func (c *ChatUpdateCall) LinkNames(linkNames bool) *ChatUpdateCall {
	c.linkNames = linkNames
	return c
}

func (c *ChatUpdateCall) Parse(parse string) *ChatUpdateCall {
	c.parse = parse
	return c
}

func (c *ChatUpdateCall) Text(text string) *ChatUpdateCall {
	c.text = text
	return c
}

func (c *ChatUpdateCall) Timestamp(timestamp string) *ChatUpdateCall {
	c.timestamp = timestamp
	return c
}

// Values() returns the ChatUpdateCall object as url.Values
func (c *ChatUpdateCall) Values() (url.Values, error) {
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.asUser {
		v.Set("asUser", "true")
	}

	if len(c.attachments) > 0 {
		attachmentsEncoded, err := c.attachments.Encode()
		if err != nil {
			return nil, errors.Wrap(err, `failed to encode field`)
		}
		v.Set("attachments", attachmentsEncoded)
	}

	if len(c.channel) <= 0 {
		return nil, errors.New(`missing required parameter channel`)
	}
	v.Set("channel", c.channel)

	if c.linkNames {
		v.Set("linkNames", "true")
	}

	if len(c.parse) > 0 {
		v.Set("parse", c.parse)
	}

	if len(c.text) > 0 {
		v.Set("text", c.text)
	}

	if len(c.timestamp) > 0 {
		v.Set("ts", c.timestamp)
	}
	return v, nil
}

// Do executes the call to access chat.update endpoint
func (c *ChatUpdateCall) Do(ctx context.Context) (*ChatResponse, error) {
	const endpoint = "chat.update"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res struct {
		SlackResponse
		*ChatResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to chat.update`)
	}
	if !res.OK {
		return nil, errors.New(res.Error.String())
	}

	return res.ChatResponse, nil
}
